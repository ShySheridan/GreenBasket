core/repository
тут описано, какие операции с данными вообще допустимы:
найти, сохранить, удалить, выбрать по условию, отсортировать.

core/service
тут собраны бизнес-правила и сценарии:
какие проверки делать, в каком порядке выполнять несколько операций, что считать ошибкой.

server
тут техническая реализация:
как реально хранить (память / БД), как запускать приложение, как подключить консоль / веб.



интерфейс ProductDetails сделать не по категориям, а по физическому типу:
LiquidDetails implements ProductDetails (volume, optional fat),
WeightedDetails implements ProductDetails (weight),
PieceDetails implements ProductDetails (piecesCount).


StockItem
Сколько именно штук этого продукта у меня есть?
Когда у этой конкретной партии истекает срок годности?
Какая была дата поставки / производства у этой партии?

Один и тот же Product → много партий:
Молоко “Бренд X, 1л, 3.2%” (один Product)
партия 1: 50 шт, произведено 01.11, годно до 10.11
партия 2: 30 шт, произведено 05.11, годно до 15.11
партия 3: 10 шт, произведено 07.11, годно до 17.11

Пользователь выбирает продукт и количество. (с партиями уникальность проверяется на уровне Product)
Находишь все StockItem для этого продукта.
Сортируешь по expirationDate или manufactureDate (чтобы списывать старые).
Начинаешь уменьшать quantity у партий (FIFO по сроку годности)


дописать такую структуру
core/
  domain/            // сущности
  repository/        // интерфейсы репозиториев
  usecase/           // интерфейсы сервисов (входные порты)
      ProductUseCase
      UserUseCase
  service/           // реализации usecase'ов
      ProductService implements ProductUseCase
      UserService implements UserUseCase


1. ядро
2. сокеты
3. многопоточность



